% Home assignment "lazy_string"

% TODO: Запретить использование std::vector и boost::shared_array, потребовав
% оптимального решения с точки зрения количества аллокаций и хранения
% длины в общих данных. boost::shared_array не хранит длину, а в vector нельзя
% использовать операторы, которые копируют символы (т.е. полезны только
% конструктор по размеру, swap, size()).
% TODO: Было бы неплохо студентам знать про трюк с массивом открытой длины
% в структуре (когда последний член структуры это массив без указания длины)
% Хотя, в стандартном C++ нет flexible array member.

\documentclass[a4paper,10pt]{article}

% Encoding support.
\usepackage{cmap}  % makes pdf files generated with pdflatex scannable and searchable
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}

% For images
\usepackage{graphicx}

\usepackage{amsmath, amsthm, amssymb}

% Spaces after commas.
\frenchspacing
% Minimal carrying number of characters,
\righthyphenmin=2

% From K.V.Voroncov Latex in samples, 2005.
\textheight=24cm   % text height
\textwidth=16cm    % text width.
\oddsidemargin=0pt % left side indention
\topmargin=-1.5cm  % top side indention.
\parindent=24pt    % paragraph indent
\parskip=0pt       % distance between paragraphs.
\tolerance=2000
\flushbottom       % page height aligning
\hoffset=0cm
%\pagestyle{empty}  % without numeration

% geometry
\usepackage[a4paper,top=15mm]{geometry}

% Indenting first paragraph.
\usepackage{indentfirst}

%\usepackage{setspace}
%\linespread{1.5}

\usepackage{enumitem}
%\usepackage{datetime}

% Listings
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyvrb}

% Auto size brackets in math equations
\usepackage{nath}
\delimgrowth=1

% To remove vertical space after title
\usepackage{titling}

% For directory listings
\usepackage{dirtree}

\begin{document}
\selectlanguage{russian}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible
}

\newcommand{\cpp}[1]{{\tt #1}}

\title{\includegraphics[height=15mm]{../CSCCPP}\\[1em]
Домашнее задание \textnumero 4 \\ Класс \cpp{lazy\_basic\_string}}
\preauthor{}
\author{}
\postauthor{}
\date{26 февраля 2017}

\maketitle

\paragraph{Постановка задачи.}

Разработайте новый класс строки.
Ваша строка должна быть близкой по интерфейсу к строке \cpp{std::basic\_string},
предлагаемой в библиотеке STL.
Основное отличие~--- ленивое копирование.

Наивная реализация \cpp{std::basic\_string} строки предполагает,
что каждый объект-строка единолично владеет своим буфером%
\footnote{В стандартах C++ до версии C++11 не накладываются ограничения на реализацию \cpp{std::basic\_string}, поэтому в некоторых реализациях STL \cpp{std::basic\_string} копируется лениво. Для обеспечения более строгих гарантий производительности в многопоточных окружениях начиная с версии стандарта C++11 в реализации \cpp{std::basic\_string} ленивое копирование фактически запрещено.}.
Такое архитектурное решение имеет много плюсов,
однако есть и существенный минус:
копирование строки является достаточно дорогой операцией,
поскольку требует выделение памяти под новый буфер.
Это, в частности, приводит к тому, что рекомендуемый способ передачи параметра объекта-строки в функцию~--- по константной ссылке,
а не по значению.
Можно предложить небольшую модификацию, которая избавит нас от такой необходимости.
Она также позволяет уменьшить потребление памяти в случае,
если в программе используются много копий одной исходной строки.

Для решения этой задачи достаточно сохранять в строке лишь ссылку на буфер и
обеспечить корректное совместное использование общего буфера между разными объектами-строками,
оперирующими в действительности одной и той же строкой. Например, средствами счетчика ссылок.
В случае же, если происходит обращение к модифицирующей операции над объектом-строкой,
а она разделяет свое владение буфером с другими объектами-строками,
необходимо выделить новый буфер и произвести модификацию именно его.
Наиболее нетривиальной становится реализация неконстантного оператора обращения по
индексу \cpp{[]}.
В случае чтения символа, строка не должна модифицироваться.
Если же происходит изменение символа,
строка должна модифицироваться согласно описанному выше правилу.

\paragraph{Требования.}
Ниже приводится список требований к интерфейсу класса,
который является подмножеством интерфейса STL \cpp{std::basic\_string}.

\begin{enumerate}
 \item Класс \cpp{lazy\_basic\_string} должен представлять собой шаблонный класс от типа символа и класса свойств символов~--- аналогично STL \cpp{std::basic\_string}, но без аллокатора.
 
 \item Класс свойств символов должен использоваться для всех операций с символами строки
 (например, для копирования буфера символов необходимо использовать статический метод \cpp{copy()} класса свойств).
 Интерфейс класса свойств символов должен соответствовать \cpp{std::char\_traits}.
 
 \item Интерфейс \cpp{lazy\_basic\_string} дожен содержать следующие методы, аналогичные методам \cpp{std::basic\_string}:

  \begin{enumerate}
   \item Типы: все, кроме аллокатора и итераторов.
   \item Конструкторы:
    \begin{enumerate}
     \item от другой ленивой строки;
     \item без параметров;
     \item неявный (!) от C-строки;
     \item заполнение заданным количеством указанных символов.
    \end{enumerate}
   \item Операторы.
    \begin{enumerate}
     \item Присваивания. % Как для константной ссылки на ленивую строку, так и для r-value ссылки.
     \item сложение \cpp{+=} и \cpp{+}. Для ленивой строки, C-строки, символа.
     \item \cpp{[]}. Обращение по индексу должно быть представлено двумя операторами~---
     константным и неконстантным.
     Второй не должен изменять строку, если действительного изменения символа не произошло.
     Обратите внимание, что тип прокси объекта для реализации этой задачи не должен быть доступен клиентам вашего класса ленивой строки.
     \item Операторы сравнения ленивых строк (достаточно реализовать операторы \cpp{==, !=, <}). Как между собой, так и с С-строками.
   \end{enumerate}
   \item Методы \cpp{swap()}, \cpp{clear()}, \cpp{size()}, \cpp{empty()}, \cpp{c\_str()} аналогичные методам \cpp{std::basic\_string}. Функция \cpp{swap()} должна быть как внутренней, так и внешней.
   
   \item Метод \cpp{size()} должен иметь временную сложность $\mathcal{O}(1)$.
  \end{enumerate}

 \item Все операции над строкой должны удовлетворять строгой гарантии безопасности исключений. Стоит заметить, что для этого {\it не} нужно использовать \cpp{try/catch}.

 \item Определите синонимы вашего класса для работы с типами \cpp{char} и \cpp{wchar\_t} соответственно \cpp{lazy\_string} и \cpp{lazy\_wstring}.

 \item Обеспечьте реализацию строки \cpp{lazy\_istring},
 нечувствительной к регистру при сравнении на основе вашей реализации \cpp{lazy\_basic\_string}.
 
 \item Постарайтесь минимизировать количество выделений динамической памяти. Например, если вы используете \cpp{std::shared\_ptr}, создавайте его с помощью \cpp{std::make\_shared}.
 
 \item Постарайтесь избежать дублирования хранимых данных. Например, размер общего буфера лучше хранить в общих данных вместе с буфером, а не в каждом экземпляре строки (если вы не реализуете описанную ниже {\it Small Object Optimization}).

 \item В данной задаче запрещено использовать готовые классы строк (в том числе, \cpp{std::basic\_string}). Остальные примитивы библиотеки STL или Boost можно и рекомендуется использовать%
\footnote{Учтите, что примитивы STL и Boost или их обычное использование могут не удовлетворять описанным требованиям данной задачи. Например, если вы используете \cpp{std::vector} для хранения буфера символов, то вы не можете использовать конструкторы копирования или операции меняющие размеры вектора, т.\,к.~в данных операциях происходит копирование символов, которое вы обязаны делать с помощью класса свойств символов (char traits).
Если вы попробуете использовать \cpp{boost::shared\_array}, то вам будет сложно хранить размер буфера вместе с буфером.}.
 
 \item Реализация должна соответствовать требованиям из Правил сдачи,
 т.\,е., например, в ней не должно быть утечек памяти,
 она должна быть оформлена в соответствии с указанными принципами кодирования и т.\,п.
\end{enumerate}

\paragraph{Опциональное задание.}
Реализуйте {\it Small Object Optimization}\footnote{Также эту оптимизацию называют {\it Small Buffer Optimization} или {\it Small String Optimization}.}.
В наивной реализации класса строки буфер символов хранится в выделяемой динамической памяти, а сам класс строки содержит указатель на этот буфер символов и длину хранимой строки.
Таким образом класс строки имеет $8 + 8 = 16$ байт накладных расходов (на 64-битной платформе, где размер указателя и размер \cpp{size\_t}~--- 8 байт).
Для коротких строк, длиной менее 8 байт, данные накладные расходы могут оказаться существенными.
В {\it Small Object Optimization} предлагается следующая идея:
для коротких строк хранить буфер символов не в динамически выделяемой памяти,
а непосредственно в поле класса строки, отведённого для хранения указателя на буфер.
Для этого в классе строки вместо указателя на буфер,
используется \cpp{union} указателя на буфер и \cpp{char[8]}:
если хранимая строка короче 8 байт,
то \cpp{union} будет использоваться как поле типа \cpp{char[8]},
если длиннее~--- то как указатель.

\paragraph{Формат сдачи.}
Решение необходимо оформить в виде библиотеки, состоящей из одного заголовочного файла.
Заголовочный файл должен называться {\tt lazy\_string.hpp}.

Класс \cpp{lazy\_basic\_string} и связанные определения типов должны быть реализованы в пространстве имен \cpp{std\_utils}.
Все необходимые вспомогательные классы и функции должны быть либо скрыты внутри класса \cpp{lazy\_basic\_string}, либо находиться в пространстве имён \cpp{std\_utils::details}.

Допускается нахождение в репозитории рядом с файлом {\tt lazy\_string.hpp} вспомогательных файлов, которые вы можете использовать для тестирования вашей библиотеки, а также {\tt Makefile/CMakeLists.txt}, они не будут участвовать в проверке.

Таким образом, ваша директория в Subversion должна выглядеть примерно следующим образом:
\dirtree{%
.1 ha4.
.2 Makefile.
.2 test.cpp.
.2 lazy\_string.hpp.
}

\paragraph{Сроки сдачи.}
Будет три срока, к которым можно будет сдавать домашнее задание:
\begin{itemize}
    \item 8:00 6 марта 2017 (понедельник),
    \item 8:00 13 марта 2017 (понедельник),
    \item 8:00 20 марта 2017 (понедельник).
\end{itemize}
Если домашнее задание не принимается с первой попытки, его
можно попробовать сдать со следующей попытки.

\end{document}
