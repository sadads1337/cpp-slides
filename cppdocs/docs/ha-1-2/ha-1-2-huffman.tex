% Home assignment "Huffman"
% TODO: документировать ввод/вывод в двоичном виде.

\documentclass[a4paper,10pt]{article}

% Encoding support.
\usepackage{cmap}  % makes pdf files generated with pdflatex scannable and searchable
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian,english]{babel}

% For images
\usepackage{graphicx}

\usepackage{qtree}

\usepackage{amsmath, amsthm, amssymb}

% Spaces after commas.
\frenchspacing
% Minimal carrying number of characters,
\righthyphenmin=2

% From K.V.Voroncov Latex in samples, 2005.
\textheight=24cm   % text height
\textwidth=16cm    % text width.
\oddsidemargin=0pt % left side indention
\topmargin=-1.5cm  % top side indention.
\parindent=24pt    % paragraph indent
\parskip=0pt       % distance between paragraphs.
\tolerance=2000
\flushbottom       % page height aligning
\hoffset=0cm
%\pagestyle{empty}  % without numeration

% geometry
\usepackage[a4paper,top=15mm]{geometry}

% Indenting first paragraph.
\usepackage{indentfirst}

%\usepackage{setspace}
%\linespread{1.5}

\usepackage{enumitem}
%\usepackage{datetime}

% Listings
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyvrb}

% Auto size brackets in math equations
\usepackage{nath}
\delimgrowth=1

% To remove vertical space after title
\usepackage{titling}

% For directory listings
\usepackage{dirtree}

\begin{document}
\selectlanguage{russian}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible
}

\title{\includegraphics[height=15mm]{../CSCCPP}\\[1em]
Домашнее задание \textnumero 2 \\ Хаффман}
\preauthor{}
\author{}
\postauthor{}
\date{16 октября 2017}

\maketitle

\paragraph{Постановка задачи.}

Напишите программу, выполняющую сжатие двухпроходным алгоритмом Хаффмана.

\paragraph{Параметры командной строки.}
Программа должна принимать в качестве аргументов ключ {\tt -c} или {\tt -d} для сжатия или распаковки соответственно, входной файл и выходной файл.
\begin{lstlisting}[frame=single]
huffman [-v] (-c|-d) input_file output_file
\end{lstlisting}

Программа должна выводить на экран статистику сжатия/распаковки:
размер исходных данных, размер полученных данных и размер,
который был использован для хранения вспомогательных данных (например, таблицы).
Не должно выводиться никакого дополнительного текста, только размеры.
Все размеры в байтах.

Например:
\begin{lstlisting}[language=bash, frame=single]
$ ./huffman -c myfile.txt result.bin
15678
6172
482
\end{lstlisting}

Размер исходного файла (исходные данные): 15678 байт, размер сжатых данных
(без дополнительной информации): 6172 байта, размер дополнительных данных:
482 байта. Рамер всего сжатого файла: $6172 + 482 = 6654$ байта.

\begin{lstlisting}[language=bash, frame=single]
$ ./huffman -d result.bin myfile_new.txt
6172
15678
482
\end{lstlisting}

Размер распакованного файла (полученные данные): 15678 байт, размер сжатых данных
(без дополнительной информации): 6172 байта, размер дополнительных данных:
482 байта. Рамер всего исходного сжатого файла: $6172 + 482 = 6654$ байта.

Обратите внимание, что \textbf{выводимые размеры это НЕ размеры входного и выходного файлов}.

Если программе передан ключ {\tt -v}, необходимо после вывода статистики сжатия или распаковки для каждого символа вывести используемую последовательность бит для его кодирования и через пробел десятичный код символа.
Последовательности бит должны быть отсортированы в лексикографическом порядке.

Рассмотрим пример сжатия и распаковки файла {\tt verbose_example.in} из архива со smoke test.

Файл {\tt verbose_example.in} содержит 15 байт: {\tt aaaaaabbbccdde\textbackslash{}xff} (где {\tt \textbackslash{}xff} соответствует символу с десятичным кодом 255).
Данному входному файлу соответствует следующее дерево Хаффмана %
\footnote{В общем случае оптимальное кодовое дерево задаётся входом неоднозначно: существует несколько эквивалентных оптимальных кодовых деревьев (например, можно инвертировать все биты в кодах Хаффмана и получить оптимальные коды Хаффмана).}:

\Tree [ [.0 `a'\ (97) ].0 [.1 [.0 [.0 `c'\ (99) ].0 [.1 `d'\ (100) ].1 ].0 [.1 [.0 [.0 `e'\ (101) ].0 [.1 (255) ].1 ].0 [.1 `b'\ (98) ].1 ].1 ].1 ]

Пример результата сжатия с ключом {\tt -v} (с выводом используемой последовательности бит для кодирования каждого символа):

\begin{lstlisting}[language=bash, frame=single]
$ ./huffman -v -c verbose_example.in compressed.bin
15
5
42
0 97
100 99
101 100
1100 101
1101 255
111 98
\end{lstlisting}

Статистика сжатия в первых стрёх строках:
15 байт~--- размер расжатых данных (исходного файла),
5 байт~--- размер сжатых данных (без дополнительной информации),
42 байта~--- размер дополнительных данных.
Итоговой размер {\tt compressed.bin}: $5 + 42 = 47$ байт.

В оставшихся строках бинарные коды, соответствующие каждому символу:
\begin{itemize}
  \item `0 97'~--- символ `a', имеющий десятичный ASCII код 97, кодируется битовой последовательностью, сотоящий из одного нуля: `0'.
  \item `100 99'~--- символ `c', имеющий десятичный ASCII код 99, кодируется битовой последовательностью `100'.
  \item ...
  \item `111 98'~--- символ `b', имеющий десятичный ASCII код 98, кодируется битовой последовательностью `111'.
\end{itemize}

Строка {\tt aaaaaabbbccdde\textbackslash{}xff} кодируется следующим потоком бит:
{\tt 0 0 0 0 0 0 111 111 111 100 100 101 101 1100 1101}.
Этот поток бит упаковывается в пять байт:
{\tt 00000011 11111111 00100101 10111001 101} (в последнем байте используется только три бита, остальные биты байта заполняются, например, нулями).

Пример результата распаковки с ключом {\tt -v} сжатого файла {\tt compressed.bin}:

\begin{lstlisting}[language=bash, frame=single]
$ ./huffman -v -d compressed.bin verbose_example_new
5
15
42
0 97
100 99
101 100
1100 101
1101 255
111 98
\end{lstlisting}


\paragraph{Ограничения.}
Наибольший размер входного файла~--- 5MB. Ограничение на время выполнения~--- 5 секунд.

\paragraph{Примечания.}
\begin{enumerate}
    \item В решении не допускается использование умных указателей.
    \item Не выводите на экран ничего, кроме требуемой статистики,
        а статистику выводите ровно в том формате, который указан в условиях.
    \item В решении не допускаются утечки памяти.
    \item Открывайте файлы в двоичном режиме ({\tt std::ios_base::binary}).
        В противном случае результат архивирования может оказаться не переносимым между платформами,
        где перевод строки представляется различным образом.
    \item Если вы записываете целочисленные переменные в двоичном виде в файл, убедитесь,
        что вы используете тип фиксированного размера (например, {\tt std::uint32_t}, но не {\tt long}).
    \item Сжатие подразумевает представление данных в компактном виде:
        не следует сериализовывать таблицу частот в результирующий файл в текстовом виде,
        или записывать сжатый алгоритмом Хаффмана поток в текстовом виде.
        Однако не требуется пытаться достичь максимальной эффективности сжатия, например,
        пытаясь сжать таблицу частот при её записи в архив.
    \item Не храните в архиве данные, которые можно вычислить.
    \item Убедитесь, что ваше решение переносимо между платформами с разными размерами базовых типов.
        Например, если вы записываете целочисленное число в двоичном виде в файл,
        используйте тип фиксированного размера, например, {\tt std::uint32_t},
        но не {\tt int}, {\tt long} или {\tt std::size_t}, которые могут иметь разные размеры на разных платформах.
        Проблемой little-endian/big-endian можно пренебречь.
    \item Для работы с байтами рекомендуется использовать тип {\tt std::uint8_t} или по крайней мере {\tt unsigned char},
        но не {\tt char}, т.к. с ним могут быть проблемы со знаковостью.
    \item Протестируйте решение на типичных граничных случаях, удостоверьтесь,
        что после разжатия сжатого файла получается исходный файл:
        \begin{enumerate}
            \item для пустого файла;
            \item для файла, содержащего ровно один байт;
            \item для файла, содержащего байт с кодом ноль;
            \item для файла, содержащего байт с кодом 255;
            \item для файла, содержащего ровно 256 различных байт;
            \item для файла, содержащего только два одинаковых байта;
            \item для больших текстовых файлов;
            \item для больших бинарных файлов;
            \item для больших файлов, содержащих случайные байты и, соответственно, плохо сжимающиеся.
        \end{enumerate}
        Используйте прилагающийся к условию архив с тестами.
    \item В случае, если выходной файл существует, его необходимо перезаписать.
        Для реализации такого поведения вам не требуется проверять существование файла:
        перезаписать файл, если он существует, это поведение по умолчанию при открытии файла на запись.
    \item Если вы используете сортировку при нахождении кодов Хаффмана, убедитесь,
        что либо вы используете стабильную сортировку,
        либо от нестабильности сортировки найденные коды для кодирования
        не меняются от запуска к запуску программы.
\end{enumerate}

\paragraph{Формат сдачи.}
В директории ha2 в репозитории должны быть четыре файла:
{\tt main.cpp, huffman.hpp, huffman.cpp} и {\tt Makefile}
или {\tt CMakeLists.txt}, если вы используете CMake.

Таким образом, ваша директория в Subversion должна выглядеть следующим образом:
\dirtree{%
.1 ha2.
.2 Makefile.
.2 main.cpp.
.2 huffman.cpp.
.2 huffman.hpp.
}

\paragraph{Сроки сдачи.}
Будет три срока, к которым можно будет сдавать домашнее задание:
\begin{itemize}
    \item 8:00 23 октября (понедельник),
    \item 8:00 30 октября (понедельник),
    \item 8:00 6 ноября (понедельник).
\end{itemize}
Если домашнее задание не принимается с первой попытки, его
можно попробовать сдать со следующей попытки.

\end{document}
